#!/bin/bash

cleanup_users() {
  # Loop through savedGitUsers, get all names, use regex to delete the ssh keys and pub,
  # Use regex to check config file and delete rows below or something
  if  [[ ! -f ~/.savedGitUsers ]]; then
    echo "No saved git users; Use setgituser to add some. Exiting..."
    return 1;
  fi
  source ~/.savedGitUsers

  # Creates a regex of list of words (account names) to NOT match, meaning all the accounts no longer in gituser files will match (if automatically added) and then will be removed.
  # ?! - If matches, DO NOT match regex
  # \\b an escaped \b for regex white space / end of word to ensure exact match of account name

  printf -v fileNames '%s|' "${!arr[@]}"
  matchedFileNames="${fileNames%|}"
  # ls | grep -P "$fileNames" | xargs -i rm -f "~/.ssh/{}"
  # echo '^id_\(\('"${matchedFileNames}"'\(.pub\)*$\)'
  # ls ~/.ssh | grep -v -E '^id_(('"${matchedFileNames}"')(.pub)*$)'
  # echo $matchedFileNames
  # List all files in ~/.ssh, then filter to only ones beginnging with id_ then filter to ones NOT inside the savedGitUsers file.
  # echo '^id_(('"${matchedFileNames}"')(.pub)*$)'
  filesToRemove=$(ls ~/.ssh | grep -E '^id_' | grep -v -E '^id_(('"${matchedFileNames}"')(.pub)*$)') 
  if [ -z "$filesToRemove"];
  then
    echo "All SSH files are clean"
  else
  echo Removing SSH Files: $filesToRemove
  # Move to .shh file, remove files, move back to prev dir
  cd ~/.ssh
  rm $filesToRemove
  cd -
  fi
  # If the array is empty match every account, since theyre not in the list.
  if  [[ ${arr[@]} -eq 0 ]]; then
  match=".*"
  else
  # Join each name match with regex for its exact match.
  printf -v joined '(?!.*\\b%s\\b)' "${!arr[@]}"
  echo "$joined test"
  match=${joined%}
  echo "Removing '"$match"' from config file"
  fi
  # .* matches all characters after the account name match,
  # [^#] do not match # means the regex stops matching on the next '# Account for' because # is excluded. (Can be 0 or 1 really because end of file)
  configRegex='(# Account for:'"${match}"' .*[^#]*)'

#### Resorted to perl as sed and pure bash wasnt allowing or working with full regex expression or multi-line files gulped all at once.
# -pi.back saves the original file before editing with .back extension
# -0pe, 0 forces perl to gulp the whole file at once, p takes a file path, e enables advanced regex
# s/pattern/replacement/flags file
# s is substitution, pattern is regex, replacement is a new line \n and flags are global / multi-line

perl -pi.back -0pe 's/'"${configRegex}"'/\n/mg' ~/.ssh/config

# Have a delete user function that uses select to choose user to delete, or multiple which removes from gitusers files and then calls this after all removed to reduce loops.

# Need to also delete ssh files
}

delete_git_user() {
    if  [[ ! -f ~/.savedGitUsers ]]; then
    echo "No saved git users; Use setgituser to add some. Exiting..."
    return 1;
  fi
  source ~/.savedGitUsers
if  [[ -v arr[@] ]]
then
select user in ${!arr[@]}
do
  echo "Removed: $user"
  unset arr[$user]
  declare -p arr > ~/.savedGitUsers
  break;
done
while true; do
    read -p "Do you want to DELETE another user? [Yn]" yn
    case $yn in
        [Nn]* ) break;;
        * ) delete_git_user; break;;
    esac
done
else
  echo "No saved git users to choose from"
fi
# Delete leftover files after deleting users.
cleanup_users
}

## TODO: Make version control agnostic, gitlab azure github etc
add_git_user() {
  if  [[ -f ~/.savedGitUsers ]]; then
    source ~/.savedGitUsers
  fi
  if [[ -v arr[@] ]]; then
  echo "Add another git user:"
  else
  declare -A arr
  echo "Add a git user:"
  fi
  declare -A repoOptions
  repoOptions[github]="github.com"
  repoOptions[gitlab]="gitlab.com"
  repoOptions[azure]="ssh.dev.azure.com"


  encryptionOptions=(rsa dsa ecdsa ed25519)
  echo "Choose the SSH Encryption type:"
  select encryption in ${encryptionOptions[@]}
do
  echo "Choose the Repository site"
select repo in ${!repoOptions[@]}
do
  read -p "Enter the git author NAME: " name
  read -p "Enter the git user EMAIL: " email
  # Add new user to the array then save it back to savedGitUsers
  
  uniqueName="$repo-$name"
  arr[$uniqueName]="$name $repo $email"
  declare -p arr > ~/.savedGitUsers
  declare -A cloneOptions
  cloneOptions[github]="git@$uniqueName:githubUserNameHere/project"
  cloneOptions[gitlab]="gitlab.com"
  cloneOptions[azure]="git@$uniqueName:v3/project"

  echo "Generating ssh keys for $uniqueName"
  eval `ssh-agent -s`
  idPath=~/.ssh/id_$uniqueName
  # generate ssh keys with email and no passphrase in the .ssh files with id_name
  ssh-keygen -q -t $encryption -C "$email" -f $idPath -N ""
  # Add the private key to the ssh agent
  ssh-add $idPath

  echo "Add the below public key to $repo - or find it at $idPath.pub "
  # Print the public key to the console
  ssh-keygen -y -f $idPath

  # Append code to ssh config with newlines between each part.
  printf "\n%s\n%s\n%s\n%s\n%s\n\n" "# Account for: $uniqueName - $email" "Host $uniqueName" "HostName ${repoOptions[$repo]}" "User git" "IdentityFile $idPath" >> ~/.ssh/config
  
  echo "Clone new repos with: git clone ${cloneOptions[$repo]}"
  while true; do
    read -p "Do you want to add another user?" yn
    case $yn in
        [Yy]* ) add_git_user; break;;
        [Nn]* ) return 1;;
        * ) echo "Please answer yes or no.";;
    esac
done
done
done
echo "use setgituser to activate the new user."
return 1
}

select_git_user() {
if  [[ ! -f ~/.savedGitUsers ]]; then
    echo "No saved git users; Use setgituser to add some. Exiting..."
    return 1
fi
source ~/.savedGitUsers
if  [[ -v arr[@] ]]
then
global=""
select user in ${!arr[@]}
do
  echo "You have chosen $user"
while true; do
    read -p "Do you want to set globally? [y/n]" yn
    case $yn in
        [Yy]* ) $global="--global"; break;;
        [Nn]* ) break;;
        * ) echo "Please answer yes or no.";;
    esac
done
echo 1
# Name Repo Email
declare -a userInfo=(${arr[$user]})
name=${userInfo[0]}
repo=${userInfo[1]}
email=${userInfo[2]}
echo 2
echo "name $name repo $repo email $email $userInfo"
echo $global
#TODO: Use variable injection to do --global rather than if
if [ "$global" = "--global" ]; then
  git config --global user.name "$name"
  git config --global user.email "$email"
  git config --global user.repo "$repo"
else
  git config user.name "$name"
  git config user.email "$email"
  git config user.repo "$repo"
fi
  return 1;
done
else
  echo "No saved git users to choose from"
fi
}

init_git_users() {
echo "Initialising git users"
mkdir -p ~/.ssh

declare -A arr
add_git_user

# declare -p arr > ~/.savedGitUsers
echo Added: ${!arr[@]}
}